### 다이나믹 프로그래밍

메모리 공간을 약간 더 사용하여 연산속도를 비약적으로 증가시키는 알고리즘

**[만족해야 하는 조건]**

- 큰 문제를 작은 문제로 나눌 수 있다
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

**[탑다운 방식과 바텀업 방식]**

1. 탑다운 방식 (Top-Down) (=메모이제이션 방식)
    
    재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법 (큰 문제를 해결하기 위해 작은 문제를 호출)
    
    ```python
    # 탑다운 DP를 이용한 피보나치 수열 소스코드
    d = [0] * 100 # 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
    
    def fibo(x):
    	# 종료 조건 (1 or 2일때 1 반환)
    	if x==1 or x==2:
    		return 1
    	# 이미 계산한적 있는 문제라면 그대로 반환
    	if d[x]!=0: 
    		return d[x]
    	# 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    	d[x] = fibo(x-1) + fibo(x-2)
    	return d[x]
    
    print(fibo(99))
    ```
    
2. 바텀업 방식 (Bottom-Up)
    
    단순히 반복문을 이요하여 소스코드를 작성하는 방식 (작은 문제부터 차근차근 답을 도출)
    
    ```python
    # 바텀업 DP를 이용한 피보나치 수열 소스코드
    d = [0] * 100
    
    d[1] = 1
    d[2] = 1
    n = 99
    
    for i in range(3,n+1):
    	d[i] = d[i-1] + d[i-2]
    
    print(d[n])
    ```
    

**[DP 문제를 푸는 방법]**

1. 브루트포스로 접근했을 때 시간이 매우 오래 걸리면 DP를 적용할 수 있는지 해결하고자 하는 *부분 문제들의 중복 여부* 확인해보기
2. 일단 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에(*탑다운*) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 *메모이제이션*을 적용할 수 있으면 코드 개선
3. 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 *바텀업 방식*으로 구현하는 것을 권장 (재귀 함수의 스택 크기가 한정되어 있을 수 있음)
